{
  "hash": "a8c11d34e42bcd0e0e9a16d8fdee69f4",
  "result": {
    "markdown": "---\ntitle: \"electron forge를 활용하여 Standalone Shiny Application 제작하기\"\ndescription: | \n  electron forge라는 기술을 활용하여 사용자의 PC에서 R과 Rstudio를 설치하지 않고도 Shiny App을 사용할 수 있게 하는 (exe) 프로그램을 만드는 방법을 소개합니다. 단, 개발 과정은 OS에 따라 조금씩 다르며, windows를 기준으로 합니다.\ncategories:\n  - R\n  - electron forge\n  - shiny\n  - quarto\n  - standalone\n  - exe\n  - windows\nauthor:\n  name: \"Jinhwan Kim\"\n  email: jinhwan@zarathu.com\n  url: https://github.com/jhk0530\nimage: img/electron-forge.png\n\nfig_width: 400\ndate: 2023-09-18\nformat: html\nexecute:\n  freeze: true\ndraft: false\nlicense: CC BY-NC\n---\n\n\n## 개요\n\n이번 글에서는 R Shiny 앱을 별도의 설치나 외부 연결 없이 폐쇄 환경에서도 실행할 수 있는 (Standalone) **exe** 파일로 패키징하는 과정을 소개합니다.\n\n## Standalone App\n\n먼저 글의 맥락을 더 효과적으로 전달하기 위해 **Standalone App**에 대해 간단히 정의해보겠습니다.\n\n*An app that can run independently without any external help.*\n\n즉, 외부에 의존하지 않고 독립적으로 실행 가능한 앱으로 정의하고 싶은데요. \n여기서 **외부**에는 보통 Shiny를 실행하기 위해 쓰이는 웹 브라우저(크롬)가 포함될 수 있습니다.\n한편, R과 Rstudio 또한 Shiny를 실행하기 위해서 (로컬에서) 필요한 **외부**로 볼 수 있습니다.\n\n즉 이러한 것들을 설치하지 않고 다운로드 이후 압축만 풀어서 바로 실행할 수 있는 것을 Standalone App이라고 하며, 이러한 예시에는\n(아시는 분이 있을진 모르겠지만) **피카츄 배구.exe**가 있습니다.\n\n<p style=\"text-align: center;\">\n  <img src='img/pikachu.png' text-align ='center'></img>    \n</p>\n\n*출처: https://gbworld.tistory.com/1362*\n\n이후 내용에서 소개되겠지만, Shiny를 standalone app으로 만드는 것은 일반적인 R/shiny 개발과는 상당히 다르고 동시에 복잡합니다.\n\n그렇다면 Standalone app으로 만드는 것은 Shiny를 사용자에게 제공하는 다른 방법들과 어떤 차이점이 있을까요?\n\n<p style=\"text-align: center;\">\n  <img src='img/flow.png' text-align ='center'></img>    \n</p>\n\n이에는 여러가지를 생각해 볼 수 있지만 크게 2가지의 차이점이 있습니다.\n\n1. 사용자 경험\n\nelectron으로 만들어진 Standalone App은 shiny를 제공하는 서버와의 네트워크 연결이 필요하지 않습니다. \nShiny를 사용하기 위해 브라우저를 열고 특정 URL에 접속하는 대신 설치된 프로그램을 실행하는 것으로 충분합니다.\n\n이로 인해 네트워크와의 데이터를 주고 받는 과정에 리소스가 쓰이지 않고, 로컬 PC의 자원을 활용하기 때문에 살짝 더 좋은 퍼포먼스를 보일 수 있습니다.\n\n2. 폐쇄성 환경\n\n또한 네트워크가 연결되지 않는다는 점은 shiny에 입력하는 값이 사용자의 PC 외부로 나가지 않고, 동시에 외부의 리소스가 PC에 들어오지 않는 다는 이야기이기도 합니다. 그렇기 때문에 망분리된 환경에서도 Shiny를 실행할 수 있고 더 뛰어난 보안성을 가지게 됩니다. (단, Shiny가 계산을 위해 외부의 API 같은 자원을 사용하려면 네트워크 연결이 필요합니다)\n\n## Electron\n\nElectron (정확히는 <a href='https://www.electronjs.org/' target = '_blank'>electron.js</a>) 은 크로미움 (크롬)과 node.js를 활용하여 html과 css, js 같은 웹 개발 결과물 (shiny가 이에 포함됩니다) 을 임베디드 형태로 만들 수 있는 프레임워크입니다.\n\n<p style=\"text-align: center;\">\n  <img src='img/electron.png' text-align ='center'></img>    \n</p>\n\nStandalone App을 만들기 위해서 electron의 기술적인 원리를 이해할 필요는 없지만, 흐름을 표현하면 아래와 같습니다.\n\n<p style=\"text-align: center;\">\n  <img src='img/electron-shiny.webp' text-align ='center'></img>    \n</p>\n\n이 기술을 활용하여 shiny로 standalone app을 만들려는 시도는 꽤 오래 전부터 있었고, 2020년에 공유된\n<a href= 'https://www.r-bloggers.com/2020/10/turn-a-shiny-application-into-a-tablet-or-desktop-app/' target = \"_blank\">Turn a shiny application into a tablet or desktop app</a> 아티클도 있지만 관련된 자료들이 2022년을 마지막으로 아카이브되어 업데이트 되지 않았기 때문에 최신의 내용을 반영한 업데이트가 필요했습니다.\n\n차라투에서는 연구를 통해 일부 내용을 최적화하고, 최근 내용들을 반영한 뒤, <a href='https://github.com/zarathucorp/shiny-electron-template-windows-2023' target = \"_blank\">Windows</a>와 <a href='https://github.com/zarathucorp/shiny-electron-template-m1-2023' target = '_blank'>M1 mac</a> 2개의 OS에서 Standalone App을 개발하여 업무에 활용하였고, 이후 개발에 활용할 수 있는 템플릿과 가이드를 무료로 제공하고 있습니다.\n\n국내에는 윈도우 사용자가 더 많기 때문에, 이번 글에서는 윈도우를 기준으로 방법을 소개합니다.\n\n## 개발 준비\n\nStandalone shiny app을 개발하기 위해 shiny 개발에 필요한 R과 Rstudio 외에 추가로 설치가 필요합니다.\n\n1. <a href='https://nodejs.org/ko' target = \"_blank\">node.js</a>\n\n글이 작성되는 23년 9월을 기준으로, LTS인 18.17.1 버전을 설치합니다.\n\n<p style=\"text-align: center;\">\n  <img src='img/node.png' text-align ='center'></img>    \n</p>\n\n이제 Rstudio를 **관리자 권한으로 실행**합니다. (아이콘을 오른쪽 클릭 후 선택)\n\n정상적으로 설치가 되었다면 Rstudio의 터미널에서 \n`node -v`, `npm -v`를 실행하여 설치 버전을 확인할 수 있습니다.\n\n2. electron-forge 설치 \n\nelectron-forge는 electron을 사용할 수 있게 하는 패키지 라고 생각하셔도 좋습니다.\n\n이는 npm을 사용해 (R의 `install.packages`와 유사) 설치할 수 있으며, 마찬가지로 Rstudio의 터미널에서 아래의 명령어를 입력하여 설치합니다.\n\n`npm i -g @electron-forge/cli`\n\n3. 템플릿 포크 / 클론\n\n차라투 github 에서 제공하는 템플릿을 자신의 계정에 포크 후, 클론하여 로컬 PC에 다운로드 받습니다.\n\n<p style=\"text-align: center;\">\n  <img src='img/fork.png' text-align ='center'></img>    \n</p>\n\n<p style=\"text-align: center;\">\n  <img src='img/clone.png' text-align ='center'></img>    \n</p>\n\n4. R project 열기\n\n템플릿 폴더의 shiny-elecgtron-template-windows-2023.Rproj를 Rstudio에서 실행합니다.\n\n이제 터미널의 작업 디렉토리가 해당 프로젝트로 고정됩니다. \n\n## Electron App 만들기\n\n1. electron app 템플릿을 설치\n\nRstudio의 터미널에서 \n\n`npx create-electron-app myApp`을 실행하여 템플릿을 설치합니다.\n\n이때 `myApp`이 standalone app의 이름이 되며 다른 이름으로 변경할 수 있지만, `app`이라는 이름은 사용이 불가능합니다.\n\n정상적으로 실행되었다면 디렉토리에 `myApp` 폴더가 새롭게 생기는 것을 확인할 수 있습니다.\n\n<p style=\"text-align: center;\">\n  <img src='img/myApp.png' text-align ='center'></img>    \n</p>\n\n2. github 템플릿의 파일을 myApp으로 이동\n\nelectron app 에서 기본으로 제공하는 템플릿은 shiny를 개발하기에는 약간 다른 내용들이 있어서 제공된 파일로 교체합니다.\n\n이때 이동해야 하는 파일은 아래의 5개입니다.\n\n- shiny 폴더\n- src 폴더\n- add-cran-binary-pkgs.R\n- get-r-win.sh\n- start-shiny.R \n\n<p style=\"text-align: center;\">\n  <img src='img/move.png' text-align ='center'></img>    \n</p>\n\n이후 Rstudio의 터미널에서 `cd myApp`으로 디렉토리를 이동합니다.\n\n3. Standalone R 설치\n\nelectron 에 포함 시킬 local R을 현재 프로젝트에 설치합니다.\n\n단, 이때 기존에 사용중인 R의 버전과 동일한 버전을 설치해야하며, 23년 9월에 최신 버전인 4.3.1을 기준으로 사용합니다.\n\nRstudio의 터미널에서 `sh ./get-r-win.sh`를 실행하는 것으로 설치할 수 있습니다.\n\n정상적으로 실행되었다면 **Done.** 메세지와 함께 폴더에 `r-win` 이라는 폴더가 새롭게 만들어 진 것을 확인할 수 있습니다. 내부의 구조는 아래와 같습니다.\n\n<p style=\"text-align: center;\">\n  <img src='img/r-win.png' text-align ='center'></img>    \n</p>\n\n4. Shiny 패키지 설치\n\n예시에서 사용하는 shiny는 shiny 폴더의 app.R 코드를 사용합니다. 이를 위해 기본 R외에 shiny를 포함한 추가 CRAN 패키지를 설치합니다.\n\nRstudio의 터미널에서 `Rscript add-cran-binary-pkgs.R`을 입력하여 패키지를 설치합니다.\n\n실행전 (기본 R 패키지)\n\n<p style=\"text-align: center;\">\n  <img src='img/before.png' text-align ='center'></img>    \n</p>\n\n실행후 (shiny를 포함한 패키지)\n\n<p style=\"text-align: center;\">\n  <img src='img/after.png' text-align ='center'></img>    \n</p>\n\n5. node 패키지 설치\n\npackage.json의 내용을 다음과 같이 [fix] package-json의 내용으로 복사 붙여넣기합니다. \n\n이때 author와 repository는 본인의 내용에 맞게 수정해야합니다.\n\n<p style=\"text-align: center;\">\n  <img src='img/package-json.png' text-align ='center'></img>    \n</p>\n\n이후 Rstudio 터미널에서 `npm install`을 입력하여 패키지를 설치할 수 있습니다.\n\n## Shiny 실행 및 패키징\n\napp.R은 개발 의도대로, 정상적으로 실행된다는 가정하에 Electron으로 shiny 를 실행하기 위해 Rstudio의 터미널에 `electron-forge start`를 입력합니다.\n\n<p style=\"text-align: center;\">\n  <img src='img/start.gif' text-align ='center'></img>    \n</p>\n\n큰 문제 없이 실행이 되었다면 이제 `electron-forge make`로 패키지를 만들 차례입니다.(zip)\n\n패키지 빌드를 위한 약간의 시간이 지난 후 out 디렉토리에서 앱과 zip 파일을 확인할 수 있습니다.\n\n:::{.columns style=\"text-align: center;\"}\n::::{.column}\n<figure>\n  <img src='img/officer1.png' width = '100%'></img>\n</figure>\n::::\n\n::::{.column}\n<figure>\n  <img src='img/officer2.png' width = '100%' style = 'margin-left: 1em'></img>\n</figure>\n::::\n:::\n\n하지만, 이렇게 png형태로 이미지를 저장하고 나면, 확대를 했을때 꺠지거나, 다른 편집이 **거의 불가능**합니다.\n\n<p style=\"text-align: center;\">\n  <img src='img/Rplot2.png' width = '500px'></img>\n</p>\n\n그러나 `officer`를 통해 벡터 그래픽으로 이미지를 저장한다면, 다음 예시처럼 파워포인트를 통해 세밀한 편집이 가능합니다.\n\n:::{.columns style=\"text-align: center;\"}\n::::{.column}\n<figure>\n  <img src='img/Rplot3.png' width = '100%'></img>\n</figure>\n::::\n\n::::{.column}\n<figure>\n  <img src='img/Rplot4.png' width = '100%' style = 'margin-left: 1em'></img>\n</figure>\n::::\n:::\n\n# 설치와 설정\n\n`officer` 패키지의 설치는 아래의 코드로 가능합니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# remotes::install_github('davidgohel/officer/')\n# remotes::install_github('davidgohel/rvg')\nlibrary(officer) # office + R\nlibrary(rvg) # r vector graphics\n```\n:::\n\n\n# officer 사용\n\n`officer`로 벡터그래픽을 만드는 흐름은 크게 4가지 순서로 구성됩니다.\n\n1. ppt 오브젝트를 만든다.\n2. ppt 오브젝트에 슬라이드를 만들고 \n3. 그 안에 이미지를 vector graphics로 넣는다.\n4. ppt 오브젝트를 저장한다.\n\n이제 각각의 내용을 소개하겠습니다.\n\n## 1. 오브젝트 만들기\n \n\n::: {.cell}\n\n```{.r .cell-code}\nppt <- read_pptx()\n\nprint(ppt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npptx document with 0 slide(s)\nAvailable layouts and their associated master(s) are:\n             layout       master\n1       Title Slide Office Theme\n2 Title and Content Office Theme\n3    Section Header Office Theme\n4       Two Content Office Theme\n5        Comparison Office Theme\n6        Title Only Office Theme\n7             Blank Office Theme\n```\n:::\n:::\n\n\n`read_pptx`는 원래 ppt 파일을 R 오브젝트 형태로 읽기 위한 함수이지만, \n만약 함수에 파일을 입력하지 않으면 새로운 ppt 오브젝트를 생성합니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nppt <- read_pptx(\"mypptx.pptx\") # 기존 ppt 읽기 \nppt <- read_pptx() # 새로운 ppt 생성\n```\n:::\n\n\n한편 `officer`에는 `read_pptx` 외에도 `read_docx`(워드), `read_xlsx`(엑셀)도 존재합니다.\n\nppt 오브젝트를 콘솔에 입력하면, 몇개의 슬라이드로 구성되어있는지 확인할 수 있습니다. (`layout`과 `master`는 신경쓰지 않으셔도 좋습니다.)\n\n## 2. 슬라이드 만들기\n\n처음 만든 ppt 오브젝트에는 **pptx document with 0 slide(s)**, 즉 슬라이드가 없습니다.\n\n이 오브젝트에 슬라이드를 추가하는 것은 `add_slide()`로 할 수 있습니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nppt |>\n  add_slide() # ppt <- ppt |> add_slide() 로 안해도 됨\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npptx document with 1 slide(s)\nAvailable layouts and their associated master(s) are:\n             layout       master\n1       Title Slide Office Theme\n2 Title and Content Office Theme\n3    Section Header Office Theme\n4       Two Content Office Theme\n5        Comparison Office Theme\n6        Title Only Office Theme\n7             Blank Office Theme\n```\n:::\n\n```{.r .cell-code}\nppt # pptx document with 1 slide(s)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npptx document with 1 slide(s)\nAvailable layouts and their associated master(s) are:\n             layout       master\n1       Title Slide Office Theme\n2 Title and Content Office Theme\n3    Section Header Office Theme\n4       Two Content Office Theme\n5        Comparison Office Theme\n6        Title Only Office Theme\n7             Blank Office Theme\n```\n:::\n:::\n\n\n`add_slide()`에는 layout과 master라는 옵션을 지정할 수 있고 가능한 값은 다음과 같습니다.\n\n- Title Slide\n- **Title and Content (기본값)**\n- Section Header\n- Two Content\n- Comparison\n- Title Only\n- Blank\n\n아마 눈치 채셨을 수도 있겠지만 레이아웃은 \n콘솔에서 ppt 오브젝트를 확인할 때 나오는 것들이며,\n\n우리의 목적은 **슬라이드 구성이 아닌 이미지 저장**이기 때문에 \n어떤 값을 선택해도 동일한 결과를 얻을 수 있습니다.\n\n아래의 이미지는 각 옵션들을 적용하여 만든 슬라이드의 결과물로 모두 동일한 것을 알 수 있습니다. \n\n<p style=\"text-align: center;\">\n  <img src='img/layout.png' width = '500px'></img>\n</p>\n\n## 3. 벡터 그래픽스 슬라이드에 추가\n\n앞서 만든 ggplot의 결과를 `ph_with`이라는 함수로 슬라이드에 추가할 수 있습니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nppt |> ph_with( # paragraph의 ph가 아닐까 생각\n  dml(ggobj = plotObj), # 앞에서 만들었던 ggplot 이미지 오브젝트\n  location = ph_location_fullsize() # 쉬운 편집을 위해 이미지의 크기를 슬라이드에 가득 채움\n)\n```\n:::\n\n\n여기서 `dml`은 <a href ='http://officeopenxml.com/drwOverview.php' target = \"_blank\">`DrawingML`</a>이라는 오피스 프로덕트(pptx)에 X**ML**로 이미지를 만들기 위한 내용입니다. location에는 다른 옵션도 있지만 **ph_location_fullsize**를 권장합니다\n\n만약 여러개의 이미지를 여러장의 슬라이드로 집어넣어 만들고 싶다면 다음처럼 `ph_with`를 pipe (`|>`)로 이어서 사용 할 수 있습니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nppt |> \n  add_slide() |> # 1번째 슬라이드 \n  ph_with(\n    dml(ggobj = plotObj),\n    location = ph_location_fullsize()\n  ) |>\n  add_slide() |> # 2번째 슬라이드\n  ph_with( \n    dml(ggobj = plotObj2),\n    location = ph_location_fullsize()\n  ) |>\n  add_slide() |> # 3번째 슬라이드 \n  ph_with( \n    dml(ggobj = plotObj3),\n    location = ph_location_fullsize()\n  )\n```\n:::\n\n\n## 4. ppt 저장\n\n마지막으로 `add_slide`와 `ph_with`를 통해 만든 슬라이드는 `print`로 \n현재 작업중인 디렉토리에 (`getwd()`로 확인) 저장할 수 있습니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngetwd() # ppt가 저장되는 위치\nppt |> \n  print(target = \"myPrint.pptx\")\n```\n:::\n\n\n이렇게 만들어진 pptx는 **파워포인트**와 **키노트**, 그리고 **구글 슬라이드**에서 작업할 수 있습니다.\n\n## 정리\n\n위 4개의 단계를 1개의 코드로 연결하면 다음과 같습니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(officer)\nlibrary(rvg)\nlibrary(ggplot2)\n\n# 이미지 생성\nplotObj <- iris |>\n  ggplot(aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +\n  geom_point()\n\n# ppt\n\nread_pptx() |> # ppt 생성, 별도의 오브젝트로 저장하지 않아도 됨.\nadd_slide() |> # 슬라이드 추가\n  ph_with( # 이미지 추가\n    dml(ggobj = plotObj), \n    location = ph_location_fullsize() \n  ) |>\nprint('image.pptx') # ppt 저장 \n```\n:::\n\n\n한편, `officer`를 활용하여 더 자세한 ppt 생성과 편집도 가능하지만, 이 글에서는 다루지 않으며 \n`quarto`를 활용한 `revealjs` 슬라이드 생성하는 방법을 <a href='https://education.zarathu.com/day3/quartopres.html' target ='_blank'>링크</a>로 대신 첨부해드립니다.\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}