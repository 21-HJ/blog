{
  "hash": "1824a651cbdafba16a206072b22df88a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"data.table의 rolling join\"\ndescription: | \n  data.table에서 제공하는 inequality join method 중 하나인 rolling merge에 대해 알아보자\ncategories:\n  - R\n  - data.table\n  \nauthor:\n  name: \"Jeongmin Seo\"\n  email: jmme42518@gmail.com\n  url: https://github.com/jmjmfasdf\nimage: img/logo.png\nfig_width: 400\ndate: 2024-12-13\nformat: html\nexecute:\n  freeze: true\ndraft: false\nlicense: CC BY-NC\n---\n\n::: {.cell}\n\n:::\n\n\n\n# 1. Introduction: Data.table\ndata.table은 대용량의 데이터를 처리하는 데 있어 빠른 속도와 메모리 효율을 보여주는 패키지이다. 또한 `dplyr`와 비교하여, `dplyr`에서 지원하지 않는 기능도 가지고 있는데, 그 중 하나인 rolling join을 소개한다. \n\n## 1. join\n일반적으로 join이라 함은 원하는 재료집합이 2개 이상일때, 이를 인결하여 새로운 집합을 만드는 연산을 의미한다. 당연히 join 연산을 할 때마다 집합이 확장되며 컬럼의 수가 증가하게 된다. join 연산의 경우 일반적으로는 equality condition을 사용한다. 즉 사용되는 집합이 일치하는 경우에만 연산이 이루어진다. 보통 이러한 조건 때문에 inner join, outter join 등을 사용하게 된다.\n\n## 2. rolling join\nrolling join은 inequality condition을 사용한다. 병합의 기준이 되는 컬럼 내에서 값을 탐색할 때, 다음과 같은 단계를 따를 수 있다.\n\n① 일단 일치하는 값이 있는지 확인하고, 없으면 선택한 방향을 따라 탐색한다.\n② 탐색 범위에 기준 값에 가장 가까운 값이 있으면 그 값이 존재하는 행과 merge를 실행한다.\n③ 탐색 범위 내에 값이 존재하지 않으면 병합을 실행하지 않는다.\n\n일반적으로 두 data.table object를 병합할 때에는 다음과 같이 실행할 수 있다. 여기서 `on = ` 을 활용해서 기준이 되는 컬럼을 지정할 수 있다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_dt <- dt1[dt2, on = .(key_column1, key_column2)]\n```\n:::\n\n\n\n그러나 rolling join을 실행하고 싶은 경우, 다음과 같이 작성할 수 있다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_dt <- dt1[dt2, on = .(key_column1, key_column2), roll = Inf] # roll option = c(Inf, -Inf, number, \"nearest\")\n```\n:::\n\n\n\n# 2. Data.table의 roll merge option\n## 1. `roll = ` 옵션  \n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n지금부터는 실제 의료 데이터를 활용하여 roll merge가 사용될 수 있는 상황에 대해 알아보고, 이를 코드로 적용해 보겠다. 데이터는 성균관대학교 바이오헬스규제학과 강의에 사용된 건강보험공단 데이터를 사용하였다. 일단 roll merge를 시행할 데이터에 대해 알아보자.\n\n### `roll = Inf`\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"병력 진단 기준 날짜(Indexdate)가 있는 data.asd 데이터\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nKey: <RN_INDI>\n   RN_INDI   COD1   COD2   SEX  Indexdate   Age Death Day_FU\n     <int> <char> <char> <int>     <Date> <int> <int>  <int>\n1:   13546                   1 2006-08-08    45     0   3432\n2:   23682                   1 2008-09-22    53     0   2656\n3:   36714                   2 2010-01-19    64     0   2172\n4:   39217                   1 2013-04-02    56     0   1003\n5:   46621                   1 2011-03-24    51     0   1743\n6:   51049                   1 2006-11-23    21     0   3325\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"병력 진단 날짜(MDCARE_STRT_DT)가 있는 m40 데이터\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   RN_INDI        RN_KEY MDCARE_STRT_DT FORM_CD MCEX_SICK_SYM\n     <int>         <i64>          <int>   <int>        <char>\n1:  596535 2002120187152       20021202       3          J209\n2:  615374 2002121012274       20021202       3          J209\n3: 1005547 2002120808216       20021202       3          J209\n4:  226594 2002120381612       20021202       3          J209\n5:  204930 2002120790182       20021202       3          J209\n6:  798943 2002040446183       20020401       3          J209\n   DETAIL_TMSG_SUBJ_CD SICK_CLSF_TYPE STD_YYYY\n                <char>          <int>    <int>\n1:                                 NA     2002\n2:                                 NA     2002\n3:                                 NA     2002\n4:                                 NA     2002\n5:                                 NA     2002\n6:                                 NA     2002\n```\n\n\n:::\n:::\n\n\n\n첫 번째 데이터는 환자별로 병력 진단 기준일이 되는 날짜가 적혀 있다. 그리고 두 번째 데이터는 환자가 병력 진단을 받았을 경우 해당 날짜가 적혀 있다. 우리는 이 데이터를 가지고, 나름의 기준을 세워서 두 데이터를 병합하는 것이 목적이다. 만약 '첫 번째 데이터의 Indexdate를 기준으로 **그 이전의 모든 날짜에서 진단일이 한 번이라도 있으면** 병력이 존재하는 것으로 간주'하려면 어떻게 해야 할까?  \n\n병합을 하는 기준이 비교하는 두 날짜가 완벽히 일치하는 것이기 아니기 때문에 일반적인 join method를 사용할 수 없다. 이러한 경우에 roll merge를 사용할 수 있다. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninfo.cci <- lapply(names(code.cci), function(x){\n  data.asd[, MDCARE_STRT_DT := Indexdate]\n  dt <- m40[like(MCEX_SICK_SYM, paste(code.cci[[x]], collapse = \"|\"))][, MDCARE_STRT_DT := as.Date(as.character(MDCARE_STRT_DT), format = \"%Y%m%d\")][, .(RN_INDI, MDCARE_STRT_DT, Incidate = MDCARE_STRT_DT)]  \n  dt[, .SD[1], keyby = c(\"RN_INDI\", \"MDCARE_STRT_DT\")][data.asd, on = c(\"RN_INDI\", \"MDCARE_STRT_DT\"), roll = Inf]})\n\nprint(head(info.cci[[10]], n = 5))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   RN_INDI MDCARE_STRT_DT   Incidate   COD1   COD2   SEX  Indexdate   Age Death\n     <int>         <Date>     <Date> <char> <char> <int>     <Date> <int> <int>\n1:   13546     2006-08-08       <NA>                   1 2006-08-08    45     0\n2:   23682     2008-09-22       <NA>                   1 2008-09-22    53     0\n3:   36714     2010-01-19 2009-12-26                   2 2010-01-19    64     0\n4:   39217     2013-04-02 2013-04-02                   1 2013-04-02    56     0\n5:   46621     2011-03-24 2011-02-16                   1 2011-03-24    51     0\n   Day_FU\n    <int>\n1:   3432\n2:   2656\n3:   2172\n4:   1003\n5:   1743\n```\n\n\n:::\n:::\n\n\n\n주의할 점은 data.table의 `on=`으로 병합을 시도할 경우에는 대상 컬럼이 이름이 같아야 한다는 것이다. 위의 코드에서는 Indexdate, incidate와 값이 같은 MDCARE_STRT_DT 컬럼을 대상으로 roll merge를 시도하였다. \n\n`roll = Inf`로 옵션을 주었기 때문에 dt의 날짜를 기준으로 data.asd를 연결할 때 정확히 일치하는 날짜가 없다면 data.asd의 날짜를 뒤로 밀어서 일치하는 날짜를 찾는다. 결과적으로 data.asd의 Indexdate 기준으로 앞 날짜에 m40의 Incidate가 존재한다면 병합이 되는 로직이라고 할 수 있다. \n\nroll merge를 사용하지 않는다면 `cartesian = T` 옵션을 사용하여 모든 가능한 조합을 허용하여 merge하고 그후에 조건에 맞게 필터링하는 과정을 거쳐야 한다. 다음은 rolling join을 사용하지 않은 코드의 예시이다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninfo.cci <- lapply(names(code.cci), function(x){\n  result <- merge(data.asd[, .(RN_INDI, Indexdate)],\n                  m40[like(MCEX_SICK_SYM, paste(code.cci[[x]], collapse = \"|\"))][order(MDCARE_STRT_DT), .SD[1], keyby = \"RN_INDI\"][, .(RN_INDI, Incidate = as.Date(as.character(MDCARE_STRT_DT), format = \"%Y%m%d\"))],\n                  by = \"RN_INDI\", all.x = T)\n  result[Indexdate < Incidate, Incidate := NA]\n  return(result)\n})\nprint(head(info.cci[[10]], n = 5))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nKey: <RN_INDI>\n   RN_INDI  Indexdate   Incidate\n     <int>     <Date>     <Date>\n1:   13546 2006-08-08       <NA>\n2:   23682 2008-09-22       <NA>\n3:   36714 2010-01-19 2005-12-09\n4:   39217 2013-04-02 2007-11-08\n5:   46621 2011-03-24 2005-09-20\n```\n\n\n:::\n:::\n\n\n일단 merge를 수행한 이후, Incidate가 가장 빠른 첫 번째 날짜를 채택하여, 그 날짜가 Indexdate보다 뒤에 있을 경우 NA로 바꾸는 방식으로 필터링하였다. 이렇게 작업하여도 **그 이전의 모든 날짜에서 진단일이 한 번이라도 있으면**이라는 조건을 만족하는 행을 필터링하는 데에는 문제가 없지만 로직의 차이로 인해 Incidate에 적힌 날짜가 다른 것을 알 수 있다. 또한 필터링 과정 때문에 코드가 길어져 가독성이 좋지 않다. \n\n### `roll = -Inf`\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"병력 진단 기준 날짜(Indexdate)가 있는 data.asd 데이터\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nKey: <RN_INDI>\n   RN_INDI   COD1   COD2   SEX  Indexdate   Age Death Day_FU MDCARE_STRT_DT\n     <int> <char> <char> <int>     <Date> <int> <int>  <int>         <Date>\n1:   13546                   1 2006-08-08    45     0   3432     2006-08-08\n2:   23682                   1 2008-09-22    53     0   2656     2008-09-22\n3:   36714                   2 2010-01-19    64     0   2172     2010-01-19\n4:   39217                   1 2013-04-02    56     0   1003     2013-04-02\n5:   46621                   1 2011-03-24    51     0   1743     2011-03-24\n6:   51049                   1 2006-11-23    21     0   3325     2006-11-23\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"병력 진단 날짜(MDCARE_STRT_DT)가 있는 m40 데이터\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   RN_INDI        RN_KEY MDCARE_STRT_DT FORM_CD MCEX_SICK_SYM\n     <int>         <i64>          <int>   <int>        <char>\n1:  596535 2002120187152       20021202       3          J209\n2:  615374 2002121012274       20021202       3          J209\n3: 1005547 2002120808216       20021202       3          J209\n4:  226594 2002120381612       20021202       3          J209\n5:  204930 2002120790182       20021202       3          J209\n6:  798943 2002040446183       20020401       3          J209\n   DETAIL_TMSG_SUBJ_CD SICK_CLSF_TYPE STD_YYYY\n                <char>          <int>    <int>\n1:                                 NA     2002\n2:                                 NA     2002\n3:                                 NA     2002\n4:                                 NA     2002\n5:                                 NA     2002\n6:                                 NA     2002\n```\n\n\n:::\n:::\n\n\n\n두 번째 예시는 동일한 데이터를 활용할 것이지만, 이번에는 '첫 번째 데이터의 Indexdate를 기준으로 **이후의 모든 날짜에서 발병 기록이 한 번이라도 있으면** 발병한 것으로 간주'하려면 어떻게 해야 할까? \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.asd[, MDCARE_STRT_DT := Indexdate]\ninfo.MI <- m40 %>% \n  .[like(MCEX_SICK_SYM, paste(code.cci[[\"MI\"]], collapse = \"|\")), .(RN_INDI, MDCARE_STRT_DT = as.Date(as.character(MDCARE_STRT_DT), format = \"%Y%m%d\"), MIdate = as.Date(as.character(MDCARE_STRT_DT), format = \"%Y%m%d\"))] %>%\n  .[data.asd, on = c(\"RN_INDI\", \"MDCARE_STRT_DT\"), roll = -Inf] \n\nprint(info.MI[40:50])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    RN_INDI MDCARE_STRT_DT     MIdate   COD1   COD2   SEX  Indexdate   Age\n      <int>         <Date>     <Date> <char> <char> <int>     <Date> <int>\n 1:  484978     2006-02-04 2006-02-04                   2 2006-02-04    63\n 2:  505228     2013-04-02       <NA>                   2 2013-04-02    45\n 3:  517447     2011-10-05       <NA>                   2 2011-10-05    61\n 4:  518792     2011-01-09       <NA>                   1 2011-01-09    50\n 5:  529690     2013-01-09       <NA>                   2 2013-01-09    58\n 6:  530990     2015-11-25       <NA>                   1 2015-11-25    63\n 7:  540586     2008-06-03       <NA>                   1 2008-06-03    59\n 8:  546772     2006-07-24       <NA>                   2 2006-07-24    19\n 9:  551252     2008-05-20       <NA>                   2 2008-05-20    73\n10:  559420     2014-12-22       <NA>                   2 2014-12-22    52\n11:  562142     2013-03-27 2013-03-27                   1 2013-03-27    53\n    Death Day_FU\n    <int>  <int>\n 1:     0   3617\n 2:     0   1003\n 3:     0   1548\n 4:     0   1817\n 5:     0   1086\n 6:     0     36\n 7:     0   2767\n 8:     0   3447\n 9:     0   2781\n10:     0    374\n11:     0   1009\n```\n\n\n:::\n:::\n\n\n\n\n`roll = -Inf`로 옵션을 주었기 때문에 m40의 날짜를 기준으로 data.asd를 연결할 때 정확히 일치하는 날짜가 없다면 data.asd의 날짜를 앞으로 당겨서 일치하는 날짜를 찾는다. 결과적으로 data.asd의 Indexdate 기준으로 뒤 날짜에 m40의 Incidate가 존재한다면 병합이 되는 로직이라고 할 수 있다. (여기서는 시작 날짜도 포함하였다.)\n\nroll merge를 사용하지 않는다면 `cartesian = T` 옵션을 사용하여 모든 가능한 조합을 허용하여 merge하고 그후에 조건에 맞게 필터링하는 과정을 거쳐야 한다. 다음은 rolling join을 사용하지 않은 코드의 예시이다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninfo.MI <- merge(data.asd[, .(RN_INDI, Indexdate)],\n                 m40[like(MCEX_SICK_SYM, paste(code.cci[[\"MI\"]], collapse = \"|\"))][order(MDCARE_STRT_DT), .SD[1], keyby = \"RN_INDI\"][, .(RN_INDI, MIdate = as.Date(as.character(MDCARE_STRT_DT), format = \"%Y%m%d\"))],\n                 by = \"RN_INDI\", all.x = T) %>%\n  .[Indexdate < MIdate, MIdate := NA]\n\nprint(info.MI[40:50])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nKey: <RN_INDI>\n    RN_INDI  Indexdate     MIdate\n      <int>     <Date>     <Date>\n 1:  484978 2006-02-04 2006-02-04\n 2:  505228 2013-04-02       <NA>\n 3:  517447 2011-10-05       <NA>\n 4:  518792 2011-01-09       <NA>\n 5:  529690 2013-01-09       <NA>\n 6:  530990 2015-11-25       <NA>\n 7:  540586 2008-06-03       <NA>\n 8:  546772 2006-07-24       <NA>\n 9:  551252 2008-05-20       <NA>\n10:  559420 2014-12-22       <NA>\n11:  562142 2013-03-27 2013-03-27\n```\n\n\n:::\n:::\n\n\n\n일단 merge를 수행한 이후, MIdate의 첫 번째 날짜를 채택하여, 그 날짜가 Indexdate보다 뒤에 있을 경우 NA로 바꾸는 방식으로 필터링하였다. 이렇게 작업하여도 **그 이전의 모든 날짜에서 진단일이 한 번이라도 있으면**이라는 조건을 만족하는 행을 필터링하는 데에는 문제가 없지만 로직의 차이로 인해 MIdate에 적힌 날짜가 다른 것을 알 수 있다. 또한 필터링 과정 때문에 코드가 길어져 가독성이 좋지 않다.\n\n정리하면 `result_dt <- dt1[dt2, on = .(key_column1, key_column2), roll = Inf]`에서 roll의 방향은 `Inf` 옵션일 때에는 dt1을 기준으로 dt2의 컬럼 값을 더 큰값으로 바꾸며 탐색하며, `-Inf` 옵션일 때에는 dt1을 기준으로 dt2의 컬럼 값을 더 작은 값으로 바꾸며 탐색한다. `roll = ` 옵션에는 숫자도 줄 수 있는데, 이 경우 정해준 컬럼 값 기준 숫자 범위 내에서만 탐색한다. `roll = nearest` 옵션에서는 양방향 탐색을 진행하되, 가장 가까운 값을 찾아서 merge를 시도한다.\n\n## 2. `rollends = ` 옵션  \n`rollends = ` 옵션을 활용하여 rolling을 시작한 경계와 끝 경계에서 어떤 동작을 취할 지 지정할 수 있다. 아래 코드 예시와 같이, `rollends` 옵션은 두 개의 boolean 값을 가진다. 첫 번째 index는 rolling 시작 경계값에 대한 처리이며, 두 번째 index는 rolling 끝 경계값에 대한 처리이다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_dt <- dt1[dt2, on = .(id), roll = Inf, rollends = c(TRUE, TRUE)]\n```\n:::\n\n\n\n즉 양 끝의 값을 포함할 것인지, 버리고 NA를 취할 것인지에 대한 조정이라고 보면 된다. `rollends = `옵션이 Inf일 경우 (T, F), -Inf일 경우 (F, T), 숫자일 경우 (F, F)이다. 이전에 사용했던 건강보험공단 데이터로 실행해보면서 알아보자. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninfo.cci <- lapply(names(code.cci), function(x){\n  data.asd[, MDCARE_STRT_DT := Indexdate]\n  dt <- m40[like(MCEX_SICK_SYM, paste(code.cci[[x]], collapse = \"|\"))][, MDCARE_STRT_DT := as.Date(as.character(MDCARE_STRT_DT), format = \"%Y%m%d\")][, .(RN_INDI, MDCARE_STRT_DT, Incidate = MDCARE_STRT_DT)]  \n  dt[, .SD[1], keyby = c(\"RN_INDI\", \"MDCARE_STRT_DT\")][data.asd, on = c(\"RN_INDI\", \"MDCARE_STRT_DT\"), roll = Inf, rollends = c(T, F)]})\n\nprint(head(info.cci[[10]], n = 5))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   RN_INDI MDCARE_STRT_DT   Incidate   COD1   COD2   SEX  Indexdate   Age Death\n     <int>         <Date>     <Date> <char> <char> <int>     <Date> <int> <int>\n1:   13546     2006-08-08 2007-03-12                   1 2006-08-08    45     0\n2:   23682     2008-09-22       <NA>                   1 2008-09-22    53     0\n3:   36714     2010-01-19 2009-12-26                   2 2010-01-19    64     0\n4:   39217     2013-04-02 2013-04-02                   1 2013-04-02    56     0\n5:   46621     2011-03-24 2011-02-16                   1 2011-03-24    51     0\n   Day_FU\n    <int>\n1:   3432\n2:   2656\n3:   2172\n4:   1003\n5:   1743\n```\n\n\n:::\n:::\n\n\n\n`roll = Inf`이므로 Incidate 기준으로 **Indexdate는 Incidate보다 큰 값이 탐지되어야** merge를 할 수 있다. 하지만 `rollends = (T, F)` 로 되어 있으므로 첫 번째 행에서 시작 바운더리인 기준값보다 작아도 roll merge가 일어난 모습을 볼 수 있다.\n\n# 3. Conclusion\n지금까지 건강보험공단 데이터를 활용하여 rolling join이 무엇이고, 왜 사용해야 하며, 어떤 상황에서 사용할 수 있는지 알아보았다. rolling join을 사용하지 않으면 `cartesian=T`옵션을 사용하여 모든 join의 수를 다 계산한 뒤 목적에 맞게 필터링을 해야 하는 추가 작업을 진행해야 했다. 하지만 rolling join 옵션을 사용하면 연구자의 목적에 맞게 inequality join을 간편하게 사용할 수 있다.\n\n- rolling join은 inequality join의 일종으로, 기준 값이 완벽하게 일치하지 않아도 주어진 목적에 맞게 두 집합을 병합할 수 있게 해 준다.\n- rolling join의 옵션은 바깥 dt를 기준으로 하여 `Inf(순방향), -Inf(역방향), number(숫자 범위), 'nearest'(방향무관)`이 있다.\n- `rollends =` 옵션을 사용하여 경계에서의 roll 여부를 결정할 수 있다.\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}